package generator

import (
	"bytes"
	"fmt"
	"github.com/hapoon/gendao/log"
	"github.com/hapoon/gendao/repository"
	"go/format"
	"regexp"
	"strings"
)

// Generator has buffer of source code
type Generator struct {
	buf bytes.Buffer
}

// TypeMap is map that relates MySQL's type to Go's type
var TypeMap = map[string]string{
	"tinyint(1)":   "bool",
	"int*unsigned": "uint",
	"int":          "int",
	"varchar":      "string",
	"text":         "string",
	"datetime":     "time.Time",
	"timestamp":    "time.Time",
	"date":         "time.Time",
}

// NullMap is map that relates MySQL's null to Go's null(database/sql)
var NullMap = map[string]string{
	"int":    "sql.NullInt64",
	"string": "sql.NullString",
	"float":  "sql.NullFloat64",
	"bool":   "sql.NullBool",
}

// Printf puts data in generator's buffer
func (rcv *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&rcv.buf, format, args...)
}

// GenerateHead makes common header
func (rcv *Generator) GenerateHead() {
	rcv.Printf("// Code generated by \"gendao\"; DO NOT EDIT\n")
	//rcv.Printf("\n")
	rcv.Printf("package dao")
	rcv.Printf("\n")
}

func (rcv *Generator) Generate(column repository.Column) {
	daoName := toCamelCaseFromSnakeCase(column.Name)
	var buf string
	isNull := false
	for _, v := range column.Data {
		if v.Null == "YES" {
			isNull = true
		}
		log.Debugf("field: %s type: %s null: %s key: %s default: %s extra: %s\n", v.Field, v.Type, v.Null, v.Key, v.Default, v.Extra)
		buf += fmt.Sprintf("\t%s\t%s\n", toCamelCaseFromSnakeCase(v.Field), generateType(v.Type, v.Null))
	}
	if isNull {
		rcv.Printf("import \"database/sql\"\n")
		rcv.Printf("\n")
	}
	rcv.Printf("type %s struct {\n", daoName)
	rcv.Printf("%s", buf)
	rcv.Printf("}\n")
}

func (rcv *Generator) Format() []byte {
	src, err := format.Source(rcv.buf.Bytes())
	if err != nil {
		log.Errorf("error: internal error: invalid Go generated: %s", err)
		log.Errorf("error: compile the package to analyze the error")
		return rcv.buf.Bytes()
	}
	return src
}


func generateType(t, n string) string {
	var ret string
	for i, v := range TypeMap {
		idx := strings.Index(t, i)
		if idx >= 0 {
			ret = v
		}
	}
	if n == "YES" {
		for i, v := range NullMap {
			idx := strings.Index(ret, i)
			if idx >= 0 {
				ret = v
			}
		}
	}
	return ret
}

func toCamelCaseFromSnakeCase(s string) string {
	rep := regexp.MustCompile(`(_|^)(.)`)
	str := rep.ReplaceAllStringFunc(s, replaceSnakeCaseToUpper)
	return str
}

func replaceSnakeCaseToUpper(s string) string {
	return strings.ToUpper(strings.Trim(s, "_"))
}
