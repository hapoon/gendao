package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"strings"

	"github.com/hapoon/gendao/log"
	"github.com/hapoon/gendao/repository"
)

// Generator has buffer of source code
type Generator struct {
	buf bytes.Buffer
}

// TypeMap is map that relates MySQL's type to Go's type
var TypeMap = map[string]string{
	"tinyint(1)":   "bool",
	"int*unsigned": "uint",
	"int":          "int",
	"float":        "float64",
	"varchar":      "string",
	"text":         "string",
	"datetime":     "time.Time",
	"timestamp":    "time.Time",
	"date":         "time.Time",
}

// NullMap is map that relates MySQL's null to Go's null(database/sql)
var NullMap = map[string]string{
	"int":    "sql.NullInt64",
	"string": "sql.NullString",
	"float":  "sql.NullFloat64",
	"bool":   "sql.NullBool",
}

// Print puts data in generator's buffer
func (g *Generator) Print(s string) {
	fmt.Fprint(&g.buf, s)
}

// Printf puts data in generator's buffer
func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

// GenerateHead makes common header
func (g *Generator) GenerateHead(packageName string) {
	g.Printf("// Package %s Code generated by \"gendao\"; DO NOT EDIT \n", packageName)
	g.Printf("package %s", packageName)
	g.Print("\n")
}

// GenerateDAO makes a part of import packages and dao struct.
func (g *Generator) GenerateDAO(column repository.Column) {
	daoName := FormatDAOName(ToCamelCaseFromSnakeCase(column.Name))
	var buf string
	isNull := false
	isTime := false
	for _, v := range column.Data {
		if v.Null == "YES" {
			isNull = true
		}
		if v.Type == "datetime" || v.Type == "timestamp" || v.Type == "date" {
			isTime = true
		}
		log.Debugf("field: %s type: %s null: %s key: %s default: %s extra: %s\n", v.Field, v.Type, v.Null, v.Key, v.Default, v.Extra)
		buf += fmt.Sprintf("\t%s\t%s\t%s\n", FormatInitialisms(ToCamelCaseFromSnakeCase(v.Field)), generateType(v.Type, v.Null), g.generateTagName(v.Field))
	}
	if isNull || isTime {
		g.Printf(`
			import(
				"database/sql"
				"reflect"
				
				"gopkg.in/gorp.v2"
		`)
		if isTime {
			g.Print("\t\"time\"\n")
		}
		g.Print(")\n")
		g.Print("\n")
	}
	daoInterfaceName := daoName + "er"
	// create dao's interface
	g.Printf(`
		// %s is %s's interface
		type %s interface {
			Find(interface{},...interface{}) (%s,error)
			FindAll(interface{},...interface{}) ([]%s,error)
		}
		`,
		daoInterfaceName, daoName,
		daoInterfaceName,
		daoName,
		daoName)
	// create dao's struct
	g.Printf(`
		// %s generated from %s table
		type %s struct {
			%s
		}
		`,
		daoName, column.Name,
		daoName,
		buf)
	// create dao interface's method
	g.Printf(`
		// TableName returns table's name
		func (rcv %s) TableName() string {
			return "%s"
		}
		`,
		daoName,
		column.Name)
	g.Printf(`
		// AddTableWithName set table's name
		func (rcv %s) AddTableWithName(dbmap *gorp.DbMap) {
			dbmap.AddTableWithName(%s{}, rcv.TableName()).SetKeys(true, "ID")
		}
		`,
		daoName,
		daoName)
	// create constructer
	g.Printf(`
		// New%s is %s's constructer
		func New%s() %s {
			return &%s{}
		}
		`,
		daoName, daoName,
		daoName, daoInterfaceName,
		daoName)
	// create Find method
	g.Printf(`
		// Find returns a data corresponding to the specified condition
		func (rcv *%s) Find(pred interface{}, args ...interface{}) (result %s, err error) {
			cols := ColNames(dbs, reflect.TypeOf(%s{}), true)
			s, args, err := sqlBuilder().
				Select(cols...).
				From(rcv.TableName()).
				Where(pred, args...).
				ToSql()
			if err != nil {
				return result, err
			}

			var resultSet []%s
			_, err = dbs.Select(&resultSet, s, args...)
			if err != nil {
				return result, err
			}
			if len(resultSet) == 0 {
				return result, sql.ErrNoRows
			}
			result = resultSet[0]
			return result, nil
		}
		`,
		daoName, daoName,
		daoName,
		daoName)
	// create FindAll method
	g.Printf(`
		// FindAll returns all data corresponding to the specified condition
		func (rcv *%s) FindAll(pred interface{}, args ...interface{}) (result []%s, err error) {
			cols := ColNames(dbs, reflect.TypeOf(%s{}), true)
			sb := sqlBuilder().
				Select(cols...).
				From(rcv.TableName())
			if pred != nil {
				sb = sb.Where(pred, args...)
			}
			s, args, err := sb.ToSql()
			if err != nil {
				return
			}

			_, err = dbs.Select(&result, s, args...)
			if err != nil {
				return
			}
			return
		}
		`,
		daoName, daoName,
		daoName)
}

// GenerateMISC makes miscellaneous functions.
func (g *Generator) GenerateMISC(daoList []string) {
	g.Print(`
		import(
			"database/sql"
			"fmt"
			"reflect"

			sq "github.com/Masterminds/squirrel"
			"gopkg.in/gorp.v2"
		)
		// DAO is data access object interface.
		type DAO interface {
			TableName() string
			AddTableWithName(dbmap *gorp.DbMap)
		}
		var (
			dbm	*gorp.DbMap
			dbs	*gorp.DbMap
			isTest bool
		)
		`)
	g.generateDAOList(daoList)
	g.Print(`
		// Config is database configuration.
		type Config struct {
			MasterDB	*sql.DB
			SlaveDB	*sql.DB
			IsTest	bool
		}

		// Initialize makes dbm and dbs usable.
		func Initialize(conf *Config) error {
			if dbm != nil {
				return fmt.Errorf("dbm has been already initialized")
			}

			dbm = &gorp.DbMap{
				Db:	conf.MasterDB,
				Dialect:	gorp.MySQLDialect{
					Engine:	"InnoDB",
					Encoding:	"utf8mb4",
				},
			}

			dbs = &gorp.DbMap{
				Db:	conf.SlaveDB,
				Dialect:	gorp.MySQLDialect{
					Engine:	"InnoDB",
					Encoding:	"utf8mb4",
				},
			}

			isTest = conf.IsTest

			addTablesWithName(dbm)
			addTablesWithName(dbs)

			return nil
		}
		// Insert function
		func Insert(d DAO) error {
			return dbm.Insert(d)
		}
		// Update function
		func Update(d DAO) (int64,error) {
			return dbm.Update(d)
		}
		// Delete function
		func Delete(d DAO) (int64,error) {
			return dbm.Delete(d)
		}
		// Truncate function(usable only test)
		func Truncate() error {
			if !isTest {
				return fmt.Errorf("Truncate is executable only in test")
			}
			if err := dbm.TruncateTables(); err != nil {
				return err
			}
			return nil
		}
		// Select function
		func Select(d DAO, rs interface{}, paramPred interface{}, paramArgs ...interface{}) error {
			typ := reflect.TypeOf(d).Elem()
			cols := ColNames(dbs, typ, true)

			sb := sqlBuilder().
				Select(cols...).
				From(d.TableName())

			if paramPred != nil {
				if len(paramArgs) > 0 {
					sb = sb.Where(paramPred, paramArgs...)
				} else {
					sb = sb.Where(paramPred)
				}
			}

			sql, args, err := sb.ToSql()

			if err != nil {
				return err
			}

			_, err = dbs.Select(rs, sql, args...)
			return err
		}
		func ColNames(dbm *gorp.DbMap, typ reflect.Type, checkPK bool) []string {
			t, err := dbm.TableFor(typ, checkPK)
			if err != nil {
				panic(err)
			}
			res := make([]string, len(t.Columns))
			for i, col := range t.Columns {
				if col.Transient == false {
					res[i] = fmt.Sprintf("%s.%s", t.TableName, col.ColumnName)
				}
			}
			return res
		}
		func sqlBuilder() sq.StatementBuilderType {
			return sq.StatementBuilder.PlaceholderFormat(sq.Question)
		}
		func addTablesWithName(dbmap *gorp.DbMap) {
			for _, dao := range daoList {
				dao.AddTableWithName(dbmap)
			}
		}
		`)
}

func (g *Generator) generateDAOList(daoList []string) {
	g.Print("var daoList = []DAO{\n")
	for _, v := range daoList {
		g.Printf("\t&%v{},\n", v)
	}
	g.Print(`}`)
}

// Format makes code formated by go-fmt
func (g *Generator) Format() []byte {
	src, err := format.Source(g.buf.Bytes())
	if err != nil {
		log.Errorf("error: internal error: invalid Go generated: %s", err)
		return g.buf.Bytes()
	}
	return src
}

func generateType(t, n string) string {
	var ret string
	for i, v := range TypeMap {
		idx := strings.Index(t, i)
		if idx >= 0 {
			ret = v
		}
	}
	if n == "YES" {
		for i, v := range NullMap {
			idx := strings.Index(ret, i)
			if idx >= 0 {
				ret = v
			}
		}
	}
	return ret
}

func (g *Generator) generateTagName(fieldName string) (result string) {
	result = fmt.Sprintf("`db:%s`", fmt.Sprintf(`"%s"`, fieldName))
	return
}
